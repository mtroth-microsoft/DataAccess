// -----------------------------------------------------------------------
// <copyright file="MySqlQueryExecution.cs" company="Lensgrinder, Ltd.">
//     Copyright (C) Lensgrinder, Ltd. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------
namespace Infrastructure.DataAccess
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// MySql Query Execution implementation.
    /// </summary>
    internal class MySqlQueryExecution : IExecutor
    {
        /// <summary>
        /// The instance's projection helper.
        /// </summary>
        private IProjectionHelper projectionHelper = new MySqlProjectionHelper();

        /// <summary>
        /// Gets the count expression.
        /// </summary>
        public string CountExpression
        {
            get
            {
                return "COUNT(*)";
            }
        }

        /// <summary>
        /// Gets a value indicating whether the protocol uses joins to generate skip.
        /// </summary>
        public bool UseJoinForSkip
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Gets the corresponding projection helper.
        /// </summary>
        public IProjectionHelper ProjectionHelper
        {
            get
            {
                return this.projectionHelper;
            }
        }

        /// <summary>
        /// Gets the bulk writer for the stoer.
        /// </summary>
        public IBulkWriter BulkWriter
        {
            get
            {
                return new MySqlBulkWriter();
            }
        }

        /// <summary>
        /// Run a union query.
        /// </summary>
        /// <param name="query">The union query to run.</param>
        /// <param name="databaseType">The database type to use.</param>
        /// <param name="shardIds">The shard ids.</param>
        /// <param name="timeout">The query timeout or null to use the default.</param>
        /// <returns>The results of the query.</returns>
        public StoredProcedureMultiple RunMultiple(
            QuerySource query,
            DatabaseType databaseType,
            IEnumerable<ShardIdentifier> shardIds,
            TimeSpan? timeout = null)
        {
            SqlFormatter formatter = new SqlFormatter();
            string commandText = MySqlQuerySerializer.Serialize(query, new ParameterContext(), formatter)
                .Insert(0, "-- AutoGenerated By DataAccess\n");
            DynamicProcedureMultiple sp = null;
            if (shardIds == null || shardIds.Count() == 0)
            {
                sp = new DynamicProcedureMultiple(databaseType);
            }
            else
            {
                sp = new DynamicProcedureMultiple(shardIds);
            }

            sp.Name = commandText;
            sp.Timeout = timeout;
            foreach (Parameter p in query.Parameters)
            {
                sp.Assign(p.ParameterName, p.Value);
            }

            sp.Execute();
            return sp;
        }

        /// <summary>
        /// Run a union query.
        /// </summary>
        /// <param name="query">The union query to run.</param>
        /// <param name="databaseType">The database type to use.</param>
        /// <param name="shardIds">The shard ids.</param>
        /// <param name="timeout">The query timeout or null to use the default.</param>
        /// <returns>The results of the query.</returns>
        public IQueryable<T> Run<T>(
            QuerySource query,
            DatabaseType databaseType,
            IEnumerable<ShardIdentifier> shardIds,
            TimeSpan? timeout = null)
        {
            SqlFormatter formatter = new SqlFormatter();
            string commandText = MySqlQuerySerializer.Serialize(query, new ParameterContext(), formatter)
                .Insert(0, "-- AutoGenerated By DataAccess\n");
            DynamicProcedure<T> sp = null;
            if (shardIds == null || shardIds.Count() == 0)
            {
                sp = new DynamicProcedure<T>(databaseType);
            }
            else
            {
                sp = new DynamicProcedure<T>(shardIds);
            }

            sp.Name = commandText;
            sp.Timeout = timeout;
            foreach (Parameter p in query.Parameters)
            {
                sp.Assign(p.ParameterName, p.Value);
            }

            return sp.Execute().AsQueryable();
        }

        /// <summary>
        /// Compile the merge statement into a procedure.
        /// </summary>
        /// <typeparam name="T">The type of the return data.</typeparam>
        /// <param name="merge">The merge query to use.</param>
        /// <param name="databaseType">The store type to use.</param>
        /// <param name="shardId">The shard id to target, if applicable.</param>
        /// <param name="timeout">The query timeout.</param>
        /// <returns>The compiled stored procedure.</returns>
        public StoredProcedure<T> CompileMerge<T>(
            MergeQuery merge,
            DatabaseType databaseType,
            ShardIdentifier shardId,
            TimeSpan? timeout = null)
        {
            bool isSingleEntity = false;
            SelectQuery sq = merge.SourceJoin.Source as SelectQuery;
            if (sq != null && sq.Source == null)
            {
                isSingleEntity = true;
            }

            string commandText = MySqlQuerySerializer.SerializeMerge(merge, isSingleEntity).Insert(0, "-- AutoGenerated By DataAccess\n");
            DynamicProcedure<T> sp = null;
            if (shardId == null)
            {
                sp = new DynamicProcedure<T>(databaseType);
            }
            else
            {
                sp = new DynamicProcedure<T>(new ShardIdentifier[] { shardId });
            }

            sp.Name = commandText;
            sp.Timeout = timeout;
            foreach (Parameter p in merge.Target.Parameters)
            {
                if (p.Value is DateTimeOffset)
                {
                    p.Value = ((DateTimeOffset)p.Value).UtcDateTime;
                    p.DbType = System.Data.DbType.DateTime;
                }

                sp.Assign(p.ParameterName, p.Value);
            }

            return sp;
        }

        /// <summary>
        /// Compile the delete queries into a procedure.
        /// </summary>
        /// <param name="deletes">The list of delete queries.</param>
        /// <param name="databaseType">The store type to use.</param>
        /// <param name="shardId">The shard id to target, if applicable.</param>
        /// <param name="timeout">The query timeout.</param>
        /// <returns>The compiled stored procedure.</returns>
        public StoredProcedureNonQuery CompileDeletes(
            List<DeleteQuery> deletes,
            DatabaseType databaseType,
            ShardIdentifier shardId,
            TimeSpan? timeout = null)
        {
            string commandText = MySqlQuerySerializer.SerializeDeletes(deletes).Insert(0, "-- AutoGenerated By DataAccess\n");

            DynamicNonQuery sp = null;
            if (shardId == null)
            {
                sp = new DynamicNonQuery(databaseType);
            }
            else
            {
                sp = new DynamicNonQuery(new ShardIdentifier[] { shardId });
            }

            sp.Name = commandText;
            sp.Timeout = timeout;
            foreach (Parameter p in deletes.First().Target.Parameters)
            {
                sp.Assign(p.ParameterName, p.Value);
            }

            return sp;
        }

        /// <summary>
        /// Compile the insert queries into a procedure.
        /// </summary>
        /// <param name="inserts">The list of insert queries.</param>
        /// <param name="databaseType">The store type to use.</param>
        /// <param name="shardId">The shard id to target, if applicable.</param>
        /// <param name="timeout">The query timeout.</param>
        /// <returns>The compiled stored procedure.</returns>
        public StoredProcedureNonQuery CompileInserts(
            List<InsertQuery> inserts,
            DatabaseType databaseType,
            ShardIdentifier shardId,
            TimeSpan? timeout = null)
        {
            string commandText = MySqlQuerySerializer.SerializeInserts(inserts).Insert(0, "-- AutoGenerated By DataAccess\n");

            DynamicNonQuery sp = null;
            if (shardId == null)
            {
                sp = new DynamicNonQuery(databaseType);
            }
            else
            {
                sp = new DynamicNonQuery(new ShardIdentifier[] { shardId });
            }

            sp.Name = commandText;
            sp.Timeout = timeout;
            foreach (Parameter p in inserts.First().Target.Parameters)
            {
                sp.Assign(p.ParameterName, p.Value);
            }

            return sp;
        }

        /// <summary>
        /// Serialize a query.
        /// </summary>
        /// <param name="query">The query to serialize.</param>
        /// <param name="context">The parameter context to use.</param>
        /// <param name="formatter">The formatter to use.</param>
        /// <returns>The serialized query.</returns>
        public string Serialize(QuerySource query, ParameterContext context, SqlFormatter formatter)
        {
            return MySqlQuerySerializer.Serialize(query, context, formatter);
        }
    }
}
