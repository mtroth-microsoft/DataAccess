// -----------------------------------------------------------------------
// <copyright file="AutoGeneratedProxy.cs" Company="Lensgrinder, Ltd.">
//     Copyright (C) Lensgrinder, Ltd. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------
namespace Infrastructure.DataAccess
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net.Http;
    using System.Reflection;
    using System.Text;
    using System.Threading.Tasks;
    using System.Web.OData;
    using System.Web.OData.Extensions;
    using System.Web.OData.Routing;
    using Microsoft.OData.Edm;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Linq;
    using OdataExpressionModel;

    /// <summary>
    /// Delegation for procedure execution.
    /// </summary>
    /// <param name="tx">The transaction to use.</param>
    /// <returns>The result of the procedure execution.</returns>
    internal delegate int ExecuteNonQuery(System.Data.IDbTransaction tx);

    /// <summary>
    /// Delegation for procedure execution.
    /// </summary>
    /// <param name="tx">The transaction to use.</param>
    /// <returns>The result of the procedure execution.</returns>
    internal delegate object ExecuteQuery(System.Data.IDbTransaction tx);

    /// <summary>
    /// Data source that uses query auto generation to retrieve data.
    /// </summary>
    public abstract class AutoGeneratedProxy : IMessageProcessor, IReferenceManager
    {
        /// <summary>
        /// The current url.
        /// </summary>
        private Uri requestUrl;

        /// <summary>
        /// Initializes a new instance of the AutoGenerated class.
        /// </summary>
        /// <param name="requestUrl">The current request's url.</param>
        protected AutoGeneratedProxy(Uri requestUrl)
        {
            this.requestUrl = requestUrl;
        }

        /// <summary>
        /// Gets the current transaction, null if not applicable.
        /// </summary>
        public virtual ITransaction CurrentTransaction
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the type of the model.
        /// </summary>
        public virtual Type ModelType
        {
            get
            {
                return this.GetType();
            }
        }

        /// <summary>
        /// Gets or sets the current message.
        /// </summary>
        public virtual HttpRequestMessage Message
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the settings used in current action, if applicable.
        /// </summary>
        protected BulkWriterSettings Settings
        {
            get;
            private set;
        }

        /// <summary>
        /// Returns the entity set data for a given type.
        /// </summary>
        /// <typeparam name="T">The type of the entity set.</typeparam>
        /// <param name="includes">Navigational properties to include.</param>
        /// <returns>The list of corresponding instances.</returns>
        public virtual IQueryable<T> Get<T>(params string[] includes) where T : class
        {
            Uri url = this.Message == null ? this.requestUrl : this.Message.RequestUri;
            QueryBuilderSettings settings = DataFilterParsingHelper.ExtractToSettings(url, typeof(T));
            DynamicQueryable<T> value = this.CreateQuery<T>(settings);

            return value;
        }

        /// <summary>
        /// Returns the single entity of the specified type.
        /// </summary>
        /// <typeparam name="T">The type of the entity.</typeparam>
        /// <param name="entityKey">The entity key.</param>
        /// <returns>The entity.</returns>
        public virtual T GetByKey<T>(InfrastructureKey entityKey) where T : class
        {
            Type type = typeof(T);
            if (this.Message != null)
            {
                ODataPath path = this.Message.ODataProperties().Path;
                IEdmNavigationSource root = path.Segments[0].GetNavigationSource(null);
                type = TypeCache.LocateType(root.EntityType().FullTypeName());
            }

            Uri url = this.Message == null ? this.requestUrl : this.Message.RequestUri;
            QueryBuilderSettings settings = DataFilterParsingHelper.ExtractToSettings(url, type);
            List<TypeCache.PathStep> steps = TypeCache.ExtractTypeSequence(url, type);
            TypeCache.PathStep returnStep = null;
            foreach (TypeCache.PathStep step in steps)
            {
                if (step.IsTypeConstraint == false)
                {
                    returnStep = step;
                }
            }

            if (url.AbsolutePath.EndsWith("$ref") && this.Message.Method.Method != "GET")
            {
                return SimpleGetByKey<T>(entityKey, url);
            }
            else if (returnStep.Type.IsAssignableFrom(typeof(T)) == true)
            {
                DynamicQueryable<T> value = this.CreateQuery<T>(settings);
                foreach (T item in value)
                {
                    return item;
                }

                return null;
            }
            else
            {
                // This addresses cases like /Servers(3L)/Services where T will be equal to Server but query wants list of services.
                MethodInfo cast = this.GetType().GetMethod("RunQuery", BindingFlags.NonPublic | BindingFlags.Instance);
                MethodInfo generic = cast.MakeGenericMethod(returnStep.Type);
                object value = generic.Invoke(this, new object[] { settings });

                T item = null;
                if (typeof(T).IsAbstract == true)
                {
                    item = Activator.CreateInstance(TypeCache.ReadDerivedTypes(typeof(T)).First()) as T;
                }
                else
                {
                    item = Activator.CreateInstance<T>();
                }

                PropertyInfo pi = typeof(T).GetProperty(returnStep.Name);
                if (typeof(IEnumerable).IsAssignableFrom(pi.PropertyType) == true ||
                    pi.PropertyType == typeof(string))
                {
                    TypeCache.SetValue(typeof(T), returnStep.Name, item, value);
                }
                else
                {
                    IEnumerable collection = value as IEnumerable;
                    foreach (object member in collection)
                    {
                        TypeCache.SetValue(typeof(T), returnStep.Name, item, member);
                        break;
                    }
                }

                return item;
            }
        }

        /// <summary>
        /// Get the configuration for the current model.
        /// </summary>
        /// <returns>The configuration.</returns>
        public virtual InfrastructureConfigType GetConfig()
        {
            InfrastructureConfigType config = ConfigurationHelper.CreateDefaultConfig();

            return config;
        }

        /// <summary>
        /// Get the list of controller types.
        /// </summary>
        /// <returns>The list of controller types.</returns>
        public virtual IEnumerable<Type> GetControllerTypes()
        {
            return new Type[] { };
        }

        /// <summary>
        /// Get the $metadata for the current model.
        /// </summary>
        /// <returns>The IEdmModel declaration.</returns>
        public abstract IEdmModel GetModel();

        /// <summary>
        /// Begins a transaction.
        /// </summary>
        /// <returns>The transaction.</returns>
        public virtual ITransaction BeginTransaction()
        {
            this.CurrentTransaction = ConfigurationHelper.CreateTransaction(this);

            return this.CurrentTransaction;
        }

        /// <summary>
        /// Creates the key for the given entity.
        /// </summary>
        /// <param name="entitySetName">The name of the entity set.</param>
        /// <param name="entity">The entity to inspect.</param>
        /// <returns>The created key.</returns>
        public virtual InfrastructureKey CreateKey(string entitySetName, object entity)
        {
            List<string> keyNames = TypeCache.GetKeys(entity.GetType());
            List<KeyValuePair<string, object>> keys = new List<KeyValuePair<string, object>>();
            foreach (string keyName in keyNames)
            {
                object value = TypeCache.GetValue(entity.GetType(), keyName, entity);
                keys.Add(new KeyValuePair<string, object>(keyName, value));
            }

            InfrastructureKey key = new InfrastructureKey(entitySetName, keys);

            return key;
        }

        /// <summary>
        /// Bulk load data into the store.
        /// </summary>
        /// <typeparam name="T">The type of the data being loaded.</typeparam>
        /// <returns>Count of rows written.</returns>
        public virtual long BulkLoad<T>()
        {
            BulkWriterSettings settings = this.ReadOptions();
            return this.BulkLoad<T>(settings);
        }

        /// <summary>
        /// Bulk load data into the store.
        /// </summary>
        /// <typeparam name="T">The type of the data being loaded.</typeparam>
        /// <param name="settings">The settings to use.</param>
        /// <returns>Count of rows written.</returns>
        public long BulkLoad<T>(BulkWriterSettings settings)
        {
            Task<string> content = this.Message.Content.ReadAsStringAsync();
            string json = content.Result;
            int pos = json.IndexOf("--batch_");
            if (pos > 0)
            {
                json = json.Substring(0, pos);
            }

            JArray array = JArray.Parse(json);
            WriterReader writerReader = new WriterReader(typeof(T));
            foreach (JObject jobject in array)
            {
                writerReader.Add(jobject);
            }

            long rowCount = 0;
            if (this.CurrentTransaction == null)
            {
                rowCount = this.Load(writerReader, settings);
            }
            else
            {
                Tuple<WriterReader, BulkWriterSettings> state =
                    new Tuple<WriterReader, BulkWriterSettings>(writerReader, settings);
                object contentId;
                this.Message.Properties.TryGetValue("ContentId", out contentId);
                int key = int.Parse(contentId.ToString());
                this.CurrentTransaction.AddObject(key, state);
            }

            this.Settings = settings;
            return rowCount;
        }

        /// <summary>
        /// Delete an instance from the datasource.
        /// </summary>
        /// <typeparam name="T">The type of the entity.</typeparam>
        /// <param name="request">The write request to process.</param>
        public virtual void Delete<T>(WriteRequest request) where T : class
        {
            DeleteQueryBuilder<T> builder = new DeleteQueryBuilder<T>(request);
            BulkWriterSettings settings = this.ReadOptions();
            StoredProcedureNonQuery sp = settings.Store.Executor.CompileDeletes(
                builder.DeleteQueries,
                settings.Store,
                settings.ShardIds.EmptyIfNull().SingleOrDefault());

            if (this.CurrentTransaction == null)
            {
                List<object> executes = new List<object>();
                executes.Add(new ExecuteNonQuery(sp.Execute));
                List<object> results = settings.Store.Executor.BulkWriter.LoadAndMergeInTransaction(executes, settings);
            }
            else
            {
                Tuple<ExecuteNonQuery, BulkWriterSettings> state =
                    new Tuple<ExecuteNonQuery, BulkWriterSettings>(sp.Execute, settings);
                object contentId;
                this.Message.Properties.TryGetValue("ContentId", out contentId);
                int key = int.Parse(contentId.ToString());
                this.CurrentTransaction.AddObject(key, state);
            }
        }

        /// <summary>
        /// Patch an instance to the datasource.
        /// </summary>
        /// <typeparam name="T">The type of the entity.</typeparam>
        /// <param name="request">The write request to process.</param>
        /// <returns>The patched entity.</returns>
        public virtual T Patch<T>(WriteRequest request) where T : class
        {
            return this.WriteData<T>(request);
        }

        /// <summary>
        /// Post an instance to the datasource.
        /// </summary>
        /// <typeparam name="T">The type of the entity.</typeparam>
        /// <param name="request">The write request to process.</param>
        /// <returns>The added entity.</returns>
        public virtual T Post<T>(WriteRequest request) where T : class
        {
            return this.WriteData<T>(request);
        }

        /// <summary>
        /// Put an instance to the datasource.
        /// </summary>
        /// <typeparam name="T">The type of the entity.</typeparam>
        /// <param name="request">The write request to process.</param>
        /// <returns>The updated entity.</returns>
        public virtual T Put<T>(WriteRequest request) where T : class
        {
            return this.WriteData<T>(request);
        }

        /// <summary>
        /// Save any pending changes.
        /// </summary>
        /// <returns>Count of changes made.</returns>
        public virtual int SaveChanges()
        {
            if (this.CurrentTransaction == null)
            {
                return 0;
            }

            List<BulkWriterSettings> listOfSettings = new List<BulkWriterSettings>();
            List<object> executes = new List<object>();
            foreach (int key in this.CurrentTransaction.GetKeys())
            {
                object state = this.CurrentTransaction.GetObject(key);
                Tuple<WriterReader, BulkWriterSettings> tuple1 = state as Tuple<WriterReader, BulkWriterSettings>;
                Tuple<ExecuteNonQuery, BulkWriterSettings> tuple2 = state as Tuple<ExecuteNonQuery, BulkWriterSettings>;
                Tuple<ExecuteQuery, BulkWriterSettings> tuple3 = state as Tuple<ExecuteQuery, BulkWriterSettings>;
                if (tuple1 != null)
                {
                    executes.Add(tuple1.Item1);
                    listOfSettings.Add(tuple1.Item2);
                }
                else if (tuple2 != null)
                {
                    executes.Add(tuple2.Item1);
                    listOfSettings.Add(tuple2.Item2);
                }
                else if (tuple3 != null)
                {
                    executes.Add(tuple3.Item1);
                    listOfSettings.Add(tuple3.Item2);
                }
            }

            int distinctStores = listOfSettings.Select(p => p.Store.Name).Distinct().Count();
            int distinctShards = listOfSettings.SelectMany(p => p.ShardIds.EmptyIfNull()).Select(p => p).Distinct().Count();

            if (distinctStores > 1 || distinctShards > 1)
            {
                throw new InvalidDataFilterException("Only one store or shard may be targeted by bulk loads in a single transaction.");
            }

            long rowCount = 0;
            BulkWriterSettings settings = listOfSettings.FirstOrDefault();
            if (settings != null)
            {
                List<object> results = settings.Store.Executor.BulkWriter.LoadAndMergeInTransaction(executes, settings);
                foreach (object result in results)
                {
                    if (result is long)
                    {
                        rowCount += (long)result;
                    }
                    else if (result is int)
                    {
                        rowCount += (int)result;
                    }
                }
            }

            return (int)rowCount;
        }

        /// <summary>
        /// Execute an action against the datasource.
        /// </summary>
        /// <typeparam name="T">The type of the return entity.</typeparam>
        /// <param name="operation">The operation to execute.</param>
        /// <returns>The query result.</returns>
        public virtual IQueryable<T> Execute<T>(ParsedOperation operation)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Execute an action against the datasource.
        /// </summary>
        /// <param name="operation">The operation to execute.</param>
        /// <returns>The query result.</returns>
        public virtual int Execute(ParsedOperation operation)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Add a reference to the host from the member.
        /// </summary>
        /// <typeparam name="T">The hosting instance type.</typeparam>
        /// <typeparam name="U">The member instance type.</typeparam>
        /// <param name="host">The host instance.</param>
        /// <param name="member">The member instance type.</param>
        /// <param name="propertyName">The name of the navigation property.</param>
        public virtual void CreateRef<T, U>(T host, U member, string propertyName)
        {
            QueryTable it;
            Dictionary<string, string> keys = TypeCache.GetOverride(typeof(T), propertyName, out it);

            if (it != null)
            {
                InsertQuery query = new InsertQuery();
                query.Target = it;
                query.Target.Hint = HintType.None;

                List<string> left = TypeCache.GetKeys(typeof(T));
                List<string> right = TypeCache.GetKeys(typeof(U));
                Dictionary<string, object> hostBag = ExtractDataToBag(left, host);
                Dictionary<string, object> memberBag = ExtractDataToBag(right, member);
                for (int i = 0; i < keys.Count; i++)
                {
                    KeyValuePair<string, string> key = keys.ElementAt(i);
                    query.Columns.Add(CreateColumn(key.Key, key.Key, hostBag[left.ElementAt(i)]));
                    query.Columns.Add(CreateColumn(key.Value, key.Value, memberBag[right.ElementAt(i)]));
                }

                BulkWriterSettings settings = this.ReadOptions();
                StoredProcedureNonQuery sp = settings.Store.Executor.CompileInserts(
                    new List<InsertQuery>() { query },
                    settings.Store,
                    settings.ShardIds.EmptyIfNull().SingleOrDefault());

                this.WriteData(sp, settings);
            }
            else
            {
                List<string> keyNames = TypeCache.GetKeys(typeof(U));
                Dictionary<string, object> memberBag = ExtractDataToBag(keys.Values, member);
                Dictionary<string, object> hostBag = ExtractDataToBag(keys.Keys, host);
                foreach (string key in keys.Keys)
                {
                    memberBag[keys[key]] = hostBag[key];
                }

                foreach (string keyName in keyNames)
                {
                    memberBag[keyName] = TypeCache.GetValue(typeof(U), keyName, member);
                }

                this.WriteData<U>(memberBag);
            }
        }

        /// <summary>
        /// Remove a reference to the host from the member.
        /// </summary>
        /// <typeparam name="T">The hosting instance type.</typeparam>
        /// <typeparam name="U">The member instance type.</typeparam>
        /// <param name="host">The host instance.</param>
        /// <param name="member">The member instance type.</param>
        /// <param name="propertyName">The name of the navigation property.</param>
        public virtual void DeleteRef<T, U>(T host, U member, string propertyName)
        {
            QueryTable it;
            Dictionary<string, string> keys = TypeCache.GetOverride(typeof(T), propertyName, out it);

            if (it != null)
            {
                AndType and = new AndType();
                List<string> left = TypeCache.GetKeys(typeof(T));
                List<string> right = TypeCache.GetKeys(typeof(U));
                Dictionary<string, object> hostBag = ExtractDataToBag(left, host);
                Dictionary<string, object> memberBag = ExtractDataToBag(right, member);
                for (int i = 0; i < keys.Count; i++)
                {
                    KeyValuePair<string, string> key = keys.ElementAt(i);
                    and.Items.Add(CreateEquals(key.Key, it.Alias, hostBag[left.ElementAt(i)]));
                    and.Items.Add(CreateEquals(key.Value, it.Alias, memberBag[right.ElementAt(i)]));
                }

                DeleteQuery query = new DeleteQuery();
                query.Filter = new FilterType() { Item = and };
                query.Target = it;
                query.Target.Hint = HintType.None;

                BulkWriterSettings settings = this.ReadOptions();
                StoredProcedureNonQuery sp = settings.Store.Executor.CompileDeletes(
                    new List<DeleteQuery>() { query },
                    settings.Store,
                    settings.ShardIds.EmptyIfNull().SingleOrDefault());

                this.WriteData(sp, settings);
            }
            else
            {
                List<string> keyNames = TypeCache.GetKeys(typeof(U));
                Dictionary<string, object> memberBag = ExtractDataToBag(keys.Values, member);
                foreach (string key in keys.Keys)
                {
                    memberBag[keys[key]] = null;
                }

                foreach (string keyName in keyNames)
                {
                    memberBag[keyName] = TypeCache.GetValue(typeof(U), keyName, member);
                }

                this.WriteData<U>(memberBag);
            }
        }

        /// <summary>
        /// Run a query using the given settings.
        /// </summary>
        /// <typeparam name="U">The type of the return set.</typeparam>
        /// <param name="settings">The settings to use.</param>
        /// <returns>The list of entities.</returns>
        internal List<U> RunQuery<U>(QueryBuilderSettings settings)
        {
            BulkWriterSettings bulkWriterSettings = ReadOptions();
            settings.Executor = bulkWriterSettings.Store.Executor ?? settings.Executor;

            QueryBuilder<U> builder = new QueryBuilder<U>(settings);
            IQueryable<U> results = builder.Run(bulkWriterSettings.Store, bulkWriterSettings.ShardIds);

            return results.ToList();
        }

        /// <summary>
        /// Extract list of property values to a property bag.
        /// </summary>
        /// <param name="properties">The list of properties.</param>
        /// <param name="instance">The instance to extract values from.</param>
        /// <returns>The property bag.</returns>
        private static Dictionary<string, object> ExtractDataToBag(IEnumerable<string> properties, object instance)
        {
            Dictionary<string, object> bag = new Dictionary<string, object>();
            foreach (string property in properties)
            {
                object value = TypeCache.GetValue(instance.GetType(), property, instance);
                bag[property] = value;
            }

            return bag;
        }

        /// <summary>
        /// Create an equal type for use in a filter.
        /// </summary>
        /// <param name="propertyName">The name of the property.</param>
        /// <param name="sourceAlias">The alias of the source for the property.</param>
        /// <param name="value">The value of the property.</param>
        /// <returns></returns>
        private static EqualType CreateEquals(string propertyName, string sourceAlias, object value)
        {
            EqualType eq = new EqualType();
            eq.Subject = new PropertyNameType() { Value = propertyName, Alias = sourceAlias };
            eq.Predicate = value;

            return eq;
        }

        /// <summary>
        /// Create a column for use in a query.
        /// </summary>
        /// <param name="name">The name of the column.</param>
        /// <param name="alias">The alias of the column.</param>
        /// <param name="value">The value of the column.</param>
        /// <returns>The created column.</returns>
        private static QueryColumn CreateColumn(string name, string alias, object value)
        {
            QueryColumn column = new QueryColumn();
            column.Name = name;
            column.Alias = alias;
            column.DefaultValue = value;
            column.Expression = PredicateType.SerializeValue(value);

            return column;
        }

        /// <summary>
        /// Write the data from the bag to a json string.
        /// </summary>
        /// <param name="memberBag">The property bag to write.</param>
        /// <returns>The json string.</returns>
        private static string WriteToJson(Dictionary<string, object> memberBag)
        {
            StringBuilder json = new StringBuilder("{");
            string separator = ", ";
            foreach (string key in memberBag.Keys)
            {
                json.AppendFormat("\"{0}\": ", key);
                json.Append(JsonConvert.SerializeObject(memberBag[key]));
                if (key != memberBag.Last().Key)
                {
                    json.Append(separator);
                }
            }

            json.Append("}");
            return json.ToString();
        }

        /// <summary>
        /// Shred the entity in the write request into a WriterReader.
        /// </summary>
        /// <typeparam name="T">The type of the entity.</typeparam>
        /// <param name="request">The write request.</param>
        /// <returns>The writer reader.</returns>
        private static WriterReader ShredToReader<T>(WriteRequest request)
        {
            StringBuilder builder = new StringBuilder();
            using (StringWriter writer = new StringWriter(builder))
            {
                using (JsonWriter jsonWriter = new JsonTextWriter(writer))
                {
                    SerializeObject(jsonWriter, request.Entity, request.Key, true);
                }
            }

            WriterReader reader = new WriterReader(typeof(T));
            JObject jo = JObject.Parse(builder.ToString());
            reader.Add(jo);

            return reader;
        }

        /// <summary>
        /// Shred the provided entity into the given writer.
        /// </summary>
        /// <param name="writer">The writer to serialize the object into.</param>
        /// <param name="entity">The entity to serialize.</param>
        /// <param name="key">The key, if applicable.</param>
        /// <param name="root">True if this is the root object, otherwise false.</param>
        private static void SerializeObject(
            JsonWriter writer, 
            IEdmEntityObject entity, 
            InfrastructureKey key = null,
            bool root = false)
        {
            EdmEntityObject eeo = entity as EdmEntityObject;            
            IEnumerable<string> properties = eeo.GetChangedPropertyNames();
            writer.WriteStartObject();
            if (root == true && key != null)
            {
                foreach (KeyValuePair<string, object> item in key.EntityKeyValues)
                {
                    writer.WritePropertyName(item.Key);
                    writer.WriteValue(item.Value);
                }
            }

            foreach (string property in properties)
            {
                if (root == true && key != null && key.EntityKeyValues.Any(p => p.Key == property))
                {
                    continue;
                }

                object value;
                entity.TryGetPropertyValue(property, out value);
                EdmEntityObjectCollection collection = value as EdmEntityObjectCollection;
                EdmEntityObject navigation = value as EdmEntityObject;
                EdmComplexObject complex = value as EdmComplexObject;
                EdmComplexObjectCollection comcoll = value as EdmComplexObjectCollection;
                EdmEnumObject enumValue = value as EdmEnumObject;
                writer.WritePropertyName(property);
                if (collection != null)
                {
                    writer.WriteStartArray();
                    foreach (IEdmEntityObject item in collection)
                    {
                        SerializeObject(writer, item);
                    }

                    writer.WriteEnd();
                }
                else if (comcoll != null)
                {
                    writer.WriteStartArray();
                    foreach (IEdmComplexObject item in comcoll)
                    {
                        SerializeObject(writer, item);
                    }

                    writer.WriteEnd();
                }
                else if (navigation != null)
                {
                    SerializeObject(writer, navigation);
                }
                else if (complex != null)
                {
                    SerializeObject(writer, complex);
                }
                else if (enumValue != null)
                {
                    writer.WriteValue(enumValue.Value);
                }
                else
                {
                    writer.WriteValue(value);
                }
            }

            writer.WriteEndObject();
        }

        /// <summary>
        /// Shred the provided complex object into the given writer.
        /// </summary>
        /// <param name="writer">The writer to serialize the object into.</param>
        /// <param name="complex">The complex object to serialize.</param>
        private static void SerializeObject(JsonWriter writer, IEdmComplexObject complex)
        {
            EdmComplexObject eco = complex as EdmComplexObject;
            IEnumerable<string> properties = eco.GetChangedPropertyNames();
            writer.WriteStartObject();
            foreach (string property in properties)
            {
                object value;
                complex.TryGetPropertyValue(property, out value);
                EdmComplexObject co = value as EdmComplexObject;
                EdmComplexObjectCollection comcoll = value as EdmComplexObjectCollection;
                writer.WritePropertyName(property);
                if (co != null)
                {
                    SerializeObject(writer, co);
                }
                else if (comcoll != null)
                {
                    writer.WriteStartArray();
                    foreach (IEdmComplexObject item in comcoll)
                    {
                        SerializeObject(writer, item);
                    }

                    writer.WriteEnd();
                }
                else
                {
                    writer.WriteValue(value);
                }
            }

            writer.WriteEndObject();
        }

        /// <summary>
        /// Write the reference data to the store.
        /// </summary>
        /// <typeparam name="T">The type of the data to write.</typeparam>
        /// <param name="propertyBag">The data to write.</param>
        private void WriteData<T>(Dictionary<string, object> propertyBag)
        {
            string json = WriteToJson(propertyBag);
            WriterReader reader = new WriterReader(typeof(T));
            reader.Add(JObject.Parse(json));

            BulkWriterSettings settings = this.ReadOptions();
            settings.OnlyUpdateChanged = false;
            SequenceExecutor<T> sequencer = new SequenceExecutor<T>(reader, settings);

            if (this.CurrentTransaction == null)
            {
                List<object> executes = new List<object>();
                executes.Add(new ExecuteQuery(sequencer.Execute));
                List<object> results = settings.Store.Executor.BulkWriter.LoadAndMergeInTransaction(executes, settings);
            }
            else
            {
                Tuple<ExecuteQuery, BulkWriterSettings> state =
                    new Tuple<ExecuteQuery, BulkWriterSettings>(sequencer.Execute, settings);
                object contentId;
                this.Message.Properties.TryGetValue("ContentId", out contentId);
                int key = int.Parse(contentId.ToString());
                this.CurrentTransaction.AddObject(key, state);
            }
        }

        /// <summary>
        /// Execute or compile a query.
        /// </summary>
        /// <param name="sp">The query to run.</param>
        private void WriteData(StoredProcedureNonQuery sp, BulkWriterSettings settings)
        {
            if (this.CurrentTransaction == null)
            {
                List<object> executes = new List<object>();
                executes.Add(new ExecuteNonQuery(sp.Execute));
                List<object> results = settings.Store.Executor.BulkWriter.LoadAndMergeInTransaction(executes, settings);
            }
            else
            {
                Tuple<ExecuteNonQuery, BulkWriterSettings> state =
                    new Tuple<ExecuteNonQuery, BulkWriterSettings>(sp.Execute, settings);
                object contentId;
                this.Message.Properties.TryGetValue("ContentId", out contentId);
                int key = int.Parse(contentId.ToString());
                this.CurrentTransaction.AddObject(key, state);
            }
        }

        /// <summary>
        /// Write the instance data to the store.
        /// </summary>
        /// <typeparam name="T">The type of the instance.</typeparam>
        /// <param name="request">The request to inspect.</param>
        /// <returns>The written instance.</returns>
        private T WriteData<T>(WriteRequest request)
        {
            WriterReader reader = ShredToReader<T>(request);
            BulkWriterSettings settings = this.ReadOptions();
            settings.OnlyUpdateChanged = false;
            SequenceExecutor<T> sequencer = new SequenceExecutor<T>(reader, settings);

            if (this.CurrentTransaction == null)
            {
                List<object> executes = new List<object>();
                executes.Add(new ExecuteQuery(sequencer.Execute));
                List<object> results = settings.Store.Executor.BulkWriter.LoadAndMergeInTransaction(executes, settings);

                return (T)results.Single();
            }
            else
            {
                Tuple<ExecuteQuery, BulkWriterSettings> state =
                    new Tuple<ExecuteQuery, BulkWriterSettings>(sequencer.Execute, settings);
                object contentId;
                this.Message.Properties.TryGetValue("ContentId", out contentId);
                int key = int.Parse(contentId.ToString());
                this.CurrentTransaction.AddObject(key, state);

                return sequencer.ReadInstance();
            }
        }

        /// <summary>
        /// Parse the url and create the query.
        /// </summary>
        /// <typeparam name="T">The type of the result set.</typeparam>
        /// <param name="settings">The settings to use.</param>
        /// <returns>The queryable.</returns>
        private DynamicQueryable<T> CreateQuery<T>(QueryBuilderSettings settings)
        {
            BulkWriterSettings bulkWriterSettings = ReadOptions();
            settings.Executor = bulkWriterSettings.Store.Executor ?? settings.Executor;

            DynamicQueryable<T> value = new DynamicQueryable<T>(
                settings,
                null,
                bulkWriterSettings.Store,
                bulkWriterSettings.ShardIds,
                null);
            value.Timeout = TimeSpan.FromSeconds(300);

            return value;
        }

        /// <summary>
        /// Read the query options for store and shards.
        /// </summary>
        /// <returns>The bulk writer settings.</returns>
        private BulkWriterSettings ReadOptions()
        {
            DatabaseType databaseType = new DefaultStoreType();
            IEnumerable<ShardIdentifier> shardIds = null;
            string user = System.Threading.Thread.CurrentPrincipal.Identity.Name;
            bool concurrency = false;

            Uri url = this.Message == null ? this.requestUrl : this.Message.RequestUri;
            Dictionary<string, string> options = DataFilterParsingHelper.ParseQueryOptions(url);
            if (options.ContainsKey("store") == true)
            {
                Type storeType = TypeCache.LocateType(options["store"]);
                databaseType = Activator.CreateInstance(storeType) as DatabaseType;
            }

            if (options.ContainsKey("concurrency") == false ||
                bool.TryParse(options["concurrency"], out concurrency) == false)
            {
                concurrency = false;
            }

            if (options.ContainsKey("user") == true)
            {
                user = options["user"];
            }

            if (options.ContainsKey("shard") == true && options["shard"] == "all")
            {
                shardIds = ShardMapManagement.Instance.GetShards(databaseType);
            }
            else if (options.ContainsKey("shard") == true)
            {
                IEnumerable<int> ids = options["shard"].Split(',').Cast<int>();
                shardIds = ShardMapManagement.Instance.GetShards(databaseType, ids);
            }

            return new BulkWriterSettings()
            {
                TransactionId = this.CurrentTransaction == null ? Guid.NewGuid() : this.CurrentTransaction.TransactionId,
                Store = databaseType,
                ShardIds = shardIds,
                DoConcurrencyCheck = concurrency,
                LeaveReaderOpen = this.CurrentTransaction == null ? true : false,
                ChangedTime = DateTimeOffset.UtcNow,
                ChangedByUser = user,
                OnlyUpdateChanged = true
            };
        }

        /// <summary>
        /// Load the data.
        /// </summary>
        /// <param name="reader">The reader to use.</param>
        /// <param name="store">The store to target.</param>
        /// <param name="shardId">The shard id to target.</param>
        /// <returns>Count of changes made.</returns>
        private long Load(WriterReader reader, BulkWriterSettings settings)
        {
            long rowCount = 0;
            do
            {
                if (settings.ShardIds.EmptyIfNull().Count() > 1)
                {
                    throw new InvalidDataFilterException("Only one store or shard may be targeted by bulk loads.");
                }

                rowCount += settings.Store.Executor.BulkWriter.LoadAndMerge(reader, settings);
            }
            while (reader.NextResult() == true);

            if (reader.IsClosed == false)
            {
                reader.Close();
            }

            return (int)rowCount;
        }

        /// <summary>
        /// Simple method to extract an instance based on the key.
        /// </summary>
        /// <typeparam name="T">The type we are querying for.</typeparam>
        /// <param name="entityKey">The key of the entity.</param>
        /// <returns>The correlative entity.</returns>
        private T SimpleGetByKey<T>(InfrastructureKey entityKey, Uri url) where T : class
        {
            Type type = typeof(T);
            QueryBuilderSettings settings = new QueryBuilderSettings();
            settings.ArgumentFilter = new FilterType();
            settings.Executor = DataFilterParsingHelper.ExtractStoreExecutor(url);
            AndType and = new AndType();
            foreach (KeyValuePair<string, object> item in entityKey.EntityKeyValues)
            {
                EqualType eq = new EqualType()
                {
                    Subject = new PropertyNameType() { Value = item.Key },
                    Predicate = item.Value
                };
                and.Items.Add(eq);
            }

            settings.ArgumentFilter.Item = and.Items.Count == 1 ? and.Items[0] : and;
            DynamicQueryable<T> value = this.CreateQuery<T>(settings);
            foreach (T item in value)
            {
                return item;
            }

            return null;
        }
    }
}
